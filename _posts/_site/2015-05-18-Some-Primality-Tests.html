<p>Today we’ll discuss a variety of primality tests - each an improvement of the last, working up to the well-known and very important <strong>Miller-Rabin test</strong>.</p>

<h3 id="a-naive-solution">A Naive Solution</h3>
<p>Naively checking primality in python is straightforward - check all possible factors!</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">isPrime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">possibleFactor</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="n">possibleFactor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span></code></pre></div>

<p>This runs in $O(n)$ time, where $n$ the <em>value</em> of the input.</p>

<p>We can do a bit better by noticing that if $p \mid n$, then $n = pq$ and so $q \mid n$. Which is to say: factors come in pairs. So we only need to check half of the factors of $n$. If we always take $p \leq q$, then $p$ is maximized at $\sqrt{n}$. So we obtain the following $O(\sqrt{n})$ solution:</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">fasterIsPrime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="n">maxFactor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">possibleFactor</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">maxFactor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">possibleFactor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span></code></pre></div>

<h3 id="this-is-slower-than-you-think">This is Slower than you think</h3>
<p>We might be tempted to look at this analysis and say: “awesome - a sublinear solution! Good job, everyone!” But a more careful look suggests we should be more cautious.</p>

<p>This analysis is parameterized on the <em>value</em> of the input, rather than the <em>length</em> of the input.</p>

<p>What’s the difference? Think of this way: in the RAM model of computation (our default model), all the inputs are strings. We don’t really know how this number is encoded, all we know it that it’s a string. If we can give a $log(n)$-length string encoding $n$ (and we can - binary is one such encoding), then now, when we talk about runtime, we parameterize on the length of the input.</p>

<p>Moreover, since real computers use binary for everything, we should we reassured that this reparameterization is not some math-voodoo-magic but instead, a more realistic representation of the computation.</p>

<p>If it helps, you can imagine we’re taking $k := len(n)$ and then working in $O(k)$ world.</p>

<p>So, with our revised analysis, $k = lg(n)$, or equivalently, $2^k = n$.  So our previous $O(n)$ solution becomes $O(2^{k})$, which is exponential!</p>

<p>So how can we do better?</p>

<p>The answer? A couple number theory tricks and some random bits!</p>

<h3 id="the-fermat-primality-test">The Fermat Primality Test</h3>

<p>If you recall, Fermat’s little theorem says, if $p$ is prime, then $a^p \equiv_p 1$ for all $a$. The contrapositive of this statement is: if $a^p \not\equiv_p 1$ for some $a$, then $p$ is not prime.</p>

<p>The Fermat primality test relies on this simple fact - we simply grab a bunch of $a$’s at random from $\mathbb{Z}_p$ and test them. If one $a$ fails the test, we know for sure that $p$ is not prime. Once we’ve checked enough $a$’s and we’re feeling good, we output “probably prime.”</p>

<p>In python,</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">random</span>
<span class="k">def</span> <span class="nf">fermatIsPrime</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">trials</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">trail</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span></code></pre></div>

<p>Line 5 uses python’s builtin $\texttt{pow}$ function, which will compute a**(n-1) % n using modular exponentiation, which is polynomial time. If we decided to first compute a**(n-1) and then mod by n, we’d be exponential, as</p>

<script type="math/tex; mode=display">len(a^{n-1}) = lg(a^{n-1}) = (n-1)lg(a)</script>

<p>This is exponential in terms of the input length. So even recording the value in memory would take exponential time!</p>

<p>So then as long as $\texttt{trials}$ is polynomial in terms of the length of $n$, $\texttt{fermatIsPrime}$ runs in poly time, which is great news!</p>

<p>Sure, there’s some probability of error. Maybe we didn’t check enough $a$’s and we just happened to miss some witness to that fact that $n$ is composite. But if $\texttt{trials}$ is really big (and polynomials can get quite big), we can be <em>almost assured</em> that “probably prime” means “is prime.”</p>

<p>With one large, unfortunate exception.</p>

<h3 id="carmichael-numbers">Carmichael Numbers</h3>

<p>Sadly, the converse of Fermat’s little theorem does not hold. Carmichael numbers are defined as composite numbers $n$ which, for all $b \in Z_n$, $b^{n-1} \equiv_n 1$.</p>

<p>Which is to say, they’re precisely the numbers that’ll slip past the Fermat test.</p>

<p>Not only that, there are infinitely many Carmichael numbers! (If you’re interested, 561 is the first Carmichael number). No matter how many times you run $\texttt{fermatIsPrime(561)}$, it will always incorrectly report that 561 is prime.</p>

<p>The fix? More number theory tricks!</p>

<h3 id="square-roots-of-unity">Square Roots of Unity</h3>

<p>Suppose $p$ is prime. We define a <em>square root of unity</em> to be some $x \in Z_p$ such that $x^2 \equiv_p 1$.</p>

<p>Certainly, $1$ and $-1$ are square roots of unity. Call these the trivial square roots of unity. We claim that there are no nontrivial square roots of unity in $Z_p$.</p>

<p>If we define $x^2 - 1$ to be a polynomial over $Z_p$, then we get for free that $1$ and $-1$ are the only square roots of unity in $Z_p$. This is as a degree $d$ polynomial has at most $d$ roots.</p>

<h3 id="fermat--roots-of-unity">Fermat + Roots of Unity</h3>

<p>Here, we’ll get a stronger claim by combining the two number-theoretic facts we have so far. This will be the basis of the Miller-Rabin primality test.</p>

<p>By Fermat’s little theorem, we know that if $p$ is prime, then $a^{p-1}$ is equivalent to $1$ mod $p$. Which means that (loose notation alert) $\sqrt{a^{p-1}}$ better be equivalent to $1$ or $-1$.</p>

<p>More formally, $\sqrt{a^{p-1}} = a^{(p-1)/2}$, and since we’re assuming $p$ is a prime bigger than 2, $p-1$ is even. So $\frac{p-1}{2}$ makes sense.</p>

<p>Further, since $p-1$ is even, we can express $p-1$ as $2^s \cdot d$ for some $s$ and $d$. So then combining Fermat’s little theorem with our square roots of unity claim gives us that either</p>

<script type="math/tex; mode=display">a^{d} \equiv_n 1</script>

<p>or</p>

<script type="math/tex; mode=display">a^{2^r \cdot d} \equiv_n -1</script>

<p>for some $0 \leq r \leq s-1$.</p>

<p>To see this - start with $a^{2^s \cdot d} = a^{p-1} \equiv_p 1$. Take a square root. Either we hit $-1$ and we stop (as we’ve satisfied the second equality), or we’re still equivalent to $1$ mod $n$. So we square root again. And so on. If we never get to $-1$, then at the end, we’ve taken out all the powers of two and we’re left with the first equality. Otherwise, we’re left with the second.</p>

<h3 id="the-miller-rabin-test">The Miller-Rabin Test</h3>

<p>Similar to how the Fermat test was based on the contrapositive of Fermat’s little theorem, the Miller-Rabin test is based on the contrapositive of the claim above. Which is to say, if there exists an $a \in Z_n^*$ such that</p>

<script type="math/tex; mode=display">a^d \not\equiv_n 1 \text{ and } a^{2^r \cdot d} \not\equiv_n -1</script>

<p>for all $0 \leq r \leq s - 1$, then $n$ is not prime.</p>

<p>So, given an input $n$ to check, we write $n-1$ as $2^s\cdot d$. And we check our two equalities. For random $a$, if $a^d \not\equiv_n 1$, return False. Then, check the second equality: loop for all $i$ and check that $a^{2^i\cdot d} \equiv -1$.</p>

<p>In python: (woohoo!)</p>

<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">powersOfTwo</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">powers</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">powers</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">powers</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">millerRabin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">trials</span><span class="p">):</span>
    <span class="c"># Where trials is some polynomial of n</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>
    <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">powersOfTwo</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
        <span class="c"># Trying to find an a that breaks our equalities</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">secondEquality</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># First equality holds, try again</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c"># Second equality holds when r == 0</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># Found a nontrivial square root of unity</span>
                <span class="k">return</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c"># Second equality holds, try again</span>
                <span class="n">secondEquality</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="c"># If we got to the end and second equality</span>
        <span class="c"># didn&#39;t hold for any of them</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">secondEquality</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span></code></pre></div>

<p>If $k$ is the number of $a$’s we try, then $\texttt{millerRabin(n, k)}$ runs in $O(k(logn)^3)$ where $n$ is the <em>value</em> of the input. Equivalently, if $n$ is the <em>length</em> of the input, then we have that $\texttt{millerRabin(n, k)}$ runs in $O(kn^3)$. Not bad! And definitely polynomial time :)</p>

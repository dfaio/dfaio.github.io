#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="no.css" />
#+OPTIONS: toc:nil
#+OPTIONS: num:nil
#+OPTIONS: html-postamble:nil
[[file:index.html][dfa.io]]

* Ok let's figure out modularity together.
  
2021-02-06
  
First we need to understand existential types. They're a form of
polymorphism.

* Existential types

Let's go rule by rule. Δ holds judgements of the form "this type is
well-formed." Γ holds judgements of the form "expression e has type
t," which we write as e : t.

#+BEGIN_EXAMPLE
 Δ, t type ⊢ τ type
---------------------
Δ ⊢ (some t. τ) type
#+END_EXAMPLE
This says that if τ is a well-formed type, then so is some t. τ. We
omit writing Γ here, as it's not relevant to the judgement.

#+BEGIN_EXAMPLE
            Δ ⊢ p type 
            Δ, t type ⊢ τ type 
            Δ Γ ⊢ e : [p/t]τ
------------------------------------------------
Δ Γ ⊢ (impl (some t.τ) with p as e) : (some t.τ)
#+END_EXAMPLE

If τ is a type referring to the free variable t, and p is some type,
then [p/t]τ is the type produced by substituting p for t in τ.

The above rule is the introduction form for expressions of existential
type. It's a sort of "backwards substitution."

The inputs are a type p to redact, a type (some t.τ) to expose, and an
expression e. If t is a type, then τ is a type. The type of e refers
to the type p. It has type [p/t]τ, a type that's constructable by
assumpting t is a type, forming τ that refers to t, and then
substituting p for t in τ.

The impl expression hides this type p in some way. (impl (some t.τ)
with p as e) has type some t.τ, which could potentially not refer to
p.

The programmer must provide an explicit typing for the impl
expression, as otherwise, there are multiple valid typings. For
instance, the (invalid in thon) expression
#+BEGIN_EXAMPLE
impl with nat as (0, 0)
#+END_EXAMPLE
could have type some t. (t * nat), some t. (nat * t), or some t. (t *
t).

#+BEGIN_EXAMPLE
            Δ Γ ⊢ e1 : (some t.τ)
            Δ, t type Γ, x : τ ⊢ e2 : τ2
            Δ ⊢ τ2 type
------------------------------------------------
Δ Γ ⊢ (use e_1 as (t, x) in e_2) : τ_2
#+END_EXAMPLE
States if we have a existential package e_1 of type (some t.τ), then
we can unpack e_1 into two new variables - a type variable t and an
expression variable x. t is an abstract type, providing opaque
reference to the type the impl redacted. x provides the implementation
specified by (some t.τ).

* A set/get existential package.
We can consider a simple set/get interface. We set a nat to an
internal vessel type. We get a nat from the internal vessel
type.

#+BEGIN_EXAMPLE
impl (some vessel. ((nat -> vessel) * (t -> vessel)))
with nat as
((
   \ x : nat -> x, (*set*)
   \ x : nat -> x  (*get*)
))
#+END_EXAMPLE
This package has type (some vessel. ((nat -> vessel) * (t ->
vessel))), but we could have just as easily implemented it as
#+BEGIN_EXAMPLE
impl (some vessel. ((nat -> vessel) * (t -> vessel)))
with (nat * nat) as
((
   \ x : nat -> (x, 0),         (*set*)
   \ x : (nat * nat)  -> fst x  (*get*)
))
#+END_EXAMPLE
It'd be pretty silly to store a single nat in a tuple of nats, of course.
But this package also has type some vessel. ((nat -> vessel) * (t -> vessel)).

Then we can use these impls as so
#+BEGIN_EXAMPLE
let setget : some vessel. ((nat -> vessel) * (t -> vessel))
    = ... (* either impl *) in
use setget as (sg, t) in
let set : (nat -> t) = fst sg in
let get : (t -> nat) = snd sg in
let s : t = set (2) in
let g : nat = get s in
g
#+END_EXAMPLE
which will evaluate to 2.

* From existential packages to something ergonomic.
  
** Modules as structures and signatures
Let's borrow syntax from section section 10.1.6 of Russo's [[https://www.microsoft.com/en-us/research/wp-content/uploads/1998/03/Types-for-Modules.pdf][Types for
Modules]]. They implemented something very similar in Moscow ML (Before
the turn of the century! Crazy how slowly type theory trickles out
into popular programming languages).

The impl and use syntax defined above is not especially
ergonomic. It's annoying to use inside an expression. I think it also
obscures the many-to-many relationship existential packages provide.
Or at the very least, does not make it especially clear.

Here is the code snippet from the link above. Convert the setget
example above to this syntax is left as an exercise to me.


#+BEGIN_EXAMPLE
signature NAT = sig type nat
                    val Z:nat
                    val S:nat -> nat
                    val plus: nat -> nat -> nat
                end

structure SafeNat = (* unlimited range but slow *)
    struct
        datatype nat = Z | S of nat
        fun plus Z m = m
          | plus (S n) m = S (plus n m)
    end
    

structure FastNat = (* limited range but fast *)
    struct type nat = int
        val Z = 0
        fun S n = n + 1
        fun plus n m = n + m
    end

type natpack = [ NAT ] (* package type *)

val safeNat = [ structure SafeNat as NAT ] (* packing *)
val fastNat = [ structure FastNat as NAT ]

structure Nat as NAT = (* unpacking *)
    if (913 mod 7 = 5) then safeNat else fastNat

val natlist = [safeNat,fastNat] : [ NAT ] list
#+END_EXAMPLE

I'm partial to the whitespace-sensitivity of python, so likely in the
long run will prefer something like

#+BEGIN_EXAMPLE
structure SafeNat:
    datatype nat = Z | S of nat
    fun plus(z nat, m nat) nat:
        case z:
            Z: m
            S n: S (plus(n, m))
#+END_EXAMPLE

*** A proposal

Consider structure declarations as equivalent to datatype
declarations, just as a way to declare additional members of the
existential packge tuple interface. Instead of being "exists t. fix
t2. sumtype", it's "exists t. tuple(...)".

It introduces an implicit pack and unpack. The user can optionally
provide a signature in the structure definition to specify what
interface type to pack in.

This means structure definitions are generative. Each structure has a
unique type. Bleh except then there's no polymorphism. The unpack has
to be explicit somewhere else.

So there's an implicit pack, and any usage of the structure has an implicit unpack?

Could start by not putting the names under the dot syntax, idk.

**** Set get as structure and signature

#+BEGIN_EXAMPLE
signature SETGET:
    type vessel
    val set nat -> vessel
    val get vessel -> nat
    
structure Setget:
    type vessel = nat
    fun set(x nat) vessel:
        return x
    fun get(v vessel) nat:
        case v:
            Vessel n:
                n
                
structure SetgetTwo:
    type vessel = (nat * nat)
    fun set(x nat) vessel:
        return (x, 0)
    fun get(v vessel) nat:
        fst(v)
#+END_EXAMPLE

#+BEGIN_EXAMPLE
structure Setget:
    datatype vessel = Vessel nat
    fun set(x nat) vessel:
        return Vessel x
    fun get(v vessel) nat:
        case v:
            Vessel n:
                n
#+END_EXAMPLE
could elaborate (roughly - ignoring the datatype) to

#+BEGIN_EXAMPLE
let SetGet : (
    some vessel. (
        (nat -> vessel) * 
        (vessel -> nat)))
    = impl (some vessel. (
            (nat -> vessel) *
            (vessel -> nat)))
      with nat as
      ( ... )
in use SetGet as (sg, SetGet.vessel) in
let SetGet.set = fst(sg) in
let SetGet.get = snd(sg) in
#+END_EXAMPLE

Hm maybe a better example is a set implementation, one as a bst and
one as a red-black tree. Then we can have two different opaque
datatypes inside two separate structures, but then we can have the
structures ascribe to the same interface.

**** Set data structure as structure and signature
This is a good example to consider, as each implementation will have
it's own separate internal datatype, so we can consider the
interaction between datatypes and structures.

I think structure definitions introduce an implicit pack and unpack,
but the user can provide a signature.

#+BEGIN_EXAMPLE
signature Set:
    type set
    val space : set -> nat
    val search : (nat * set) -> bool
    val insert : (nat * set) -> set
    val delete : (nat * set) -> set
    
signature Bst as Set:
    datatype set = Nil | Node (nat * set * set)
    ...

signature Rbt as Set:
    datatype set = Nil | Node (nat * bool * set * set)
    ...
#+END_EXAMPLE
Bst could elaborate to (note the ctors for tree aren't exported -
though they could be, if the user wants to - just elaborate them as if
it was a datatype decl outside of the structure).

#+BEGIN_EXAMPLE
let BstImpl : (
    some set. (
        (set -> nat) * 
        ((nat * set) -> bool) *
        ((nat * set) -> set) *
        ((nat * set) -> set))
    = impl (some set. (
                (set -> nat) * 
                ((nat * set) -> bool) *
                ((nat * set) -> set) *
                ((nat * set) -> set)))
      with (u t . (unit | (nat * t * t))) as
      ( ... )
in use BstImpl as (Bst, Bst.set) in
let Bst.space = fst(sg) in
let Bst.search = snd(sg) in
..
#+END_EXAMPLE
If we want to export the type set, we'd need a way to introduce
another opaque type variable for that type.

*** Outstanding questions
- What is a structure without a signature? Just a named tuple?
- What is a signature without a structure? Just a type? If so, then
#+BEGIN_EXAMPLE
signature NatSig:
    type nat
    val Z nat
    val S nat -> nat
#+END_EXAMPLE

is sugar for

#+BEGIN_EXAMPLE
type NatSig = some nat . (Z: nat * s: nat -> nat)
#+END_EXAMPLE

- Why does Moscow ML require type natpack = [ NAT ] to define the package type?
- Can the programmer use a structure without first packing and unpackin
** Modules as generalized tuples
Modules are kind of like named tuples where some of the names refer to
expressions and some of the names refer to types. A type name could be
opaque or transparent. If it is opaque, it sits underneath existential
quantification. If it is transparent, it sits outside the
quantification as a named member in the tuple.

Names could be private as well, but that might require implementing
subtyping, which I don't really want to do, as it seems very
complicated. And I don't want to have an ad hoc solution here.

So for now, we'll demand that all names defined inside the named tuple
are visible outside the named tuple.

** Modules as datatypes
   
Algebraic datatypes in thon elaborate to existential packages. This
approach is borrowed from section 3.4 of Harper and Stone's [[https://www.cs.cmu.edu/~rwh/papers/ttisml/ttisml.pdf][A type-theoretic
interpretation of standard ML]]. For instance, the datatype

#+BEGIN_EXAMPLE
data List = Nil | Cons int * List
#+END_EXAMPLE
elaborates (roughly) to

#+BEGIN_EXAMPLE
let ListImpl : (some t. ((unit -> t) * (((nat*t) -> t)))) =
    impl (some t. ((unit -> t) * (((nat * t) -> t))))
    with (u List. (unit |  (nat * List))) as
    (
        (* Nil *)
        \ foo : unit ->
            fold u List. (unit | (nat * List))
            with left foo : 
                (unit 
               | (nat * (u List . (unit | (nat * List)))))
        ,
        (* Cons *)
        \ natAndNatList :
            (nat * (u List. (unit |  (nat * List)))) ->
            fold u List.(unit |  (nat * List))
            with right natAndNatList :
                (unit
               | (nat * (u List. (unit |  (nat * List)))))
    )
in use ListImpl as (li, List) in
let Nil : unit -> List = fst li in
let Cons : (nat * List) -> List = snd li in
Z
#+END_EXAMPLE
There is an additional "expose" function that is generated. In the
example above, it would map from the abstract type List to the type
((unit -> t) * (((nat * t) -> t))). The expose function would then be
implicitly called when case-ing on a datatype.

So notably, datatypes sort-of a special case of modules. Why not unify the syntax?

  

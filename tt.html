<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="My Friend" />
  <title>From types to programming languages – Just say hello!</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */
  </style>
  <link rel="stylesheet" href="thon.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">Just say hello!</h1>
<p class="author">My Friend</p>
</header>
<h1 id="from-types-to-programming-languages">from types to programming languages</h1>
<p>hello. this is a document talking about how to write programming languages. the type theory research community has many good ideas. i’d like to learn some and share what i learn here.</p>
<h2 id="a-simple-lambda-calculus">a simple lambda calculus</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode sml"><code class="sourceCode sml"><a class="sourceLine" id="cb1-1" title="1">    <span class="kw">datatype</span> exp =</a>
<a class="sourceLine" id="cb1-2" title="2">        Zero</a>
<a class="sourceLine" id="cb1-3" title="3">      | Var <span class="kw">of</span> <span class="dt">string</span> * <span class="dt">int</span> <span class="co">(* idx into ctx *)</span></a>
<a class="sourceLine" id="cb1-4" title="4">      | Succ <span class="kw">of</span> exp</a>
<a class="sourceLine" id="cb1-5" title="5">      | Fn <span class="kw">of</span> <span class="dt">string</span> * typ <span class="co">(*argType*)</span> * exp <span class="co">(*funcBody*)</span></a>
<a class="sourceLine" id="cb1-6" title="6">      | Let <span class="kw">of</span> <span class="dt">string</span> * typ <span class="co">(*vartype*)</span> * exp <span class="co">(*varval*)</span> * exp <span class="co">(*varscope*)</span></a>
<a class="sourceLine" id="cb1-7" title="7">      | App <span class="kw">of</span> exp * exp</a>
<a class="sourceLine" id="cb1-8" title="8">      | Fix <span class="kw">of</span> <span class="dt">string</span> <span class="co">(*x*)</span> * typ <span class="co">(*: t*)</span> * exp <span class="co">(*x&#39;s scope*)</span></a>
<a class="sourceLine" id="cb1-9" title="9">      | TypFn <span class="kw">of</span> <span class="dt">string</span> * exp <span class="co">(* binds type variable *)</span></a>
<a class="sourceLine" id="cb1-10" title="10">      | Ifz <span class="kw">of</span> exp * exp * <span class="dt">string</span> * exp</a>
<a class="sourceLine" id="cb1-11" title="11">      | TypApp <span class="kw">of</span> typ * exp</a>
<a class="sourceLine" id="cb1-12" title="12">      | Pair <span class="kw">of</span> exp * exp</a>
<a class="sourceLine" id="cb1-13" title="13">      <span class="co">(* Elimination forms for terms of Prod type *)</span></a>
<a class="sourceLine" id="cb1-14" title="14">      | ProdLeft <span class="kw">of</span> exp</a>
<a class="sourceLine" id="cb1-15" title="15">      | ProdRight <span class="kw">of</span> exp</a></code></pre></div>
<p>pcf is a small functional programming language. It has a couple nice things and really nothing else: natural numbers, functions, recursion, and polymorphism.</p>
<p>Here’s some code:</p>
<pre><code>let isone : nat -&gt; nat = 
  \ n : nat -&gt;
    ifz n of
      Z -&gt; Z (*false*)
    | S p -&gt; ifz p of Z -&gt; S Z | S p -&gt; Z
in fun iseven : nat -&gt; nat =
  \ n : nat -&gt;
    ifz n of
      Z -&gt; S Z (*true*)
    | S p -&gt; ifz (iseven p) of Z -&gt; S Z | S p -&gt; Z
in fun divbytwo : nat -&gt; nat =
  \ n : nat -&gt;
    ifz n of
      Z -&gt; Z
    | S p -&gt; ifz p of Z -&gt; Z | S p&#39; -&gt; (S (divbytwo p&#39;))
in fun multbythree : nat -&gt; nat =
  \ n : nat -&gt;
    ifz n of
      Z -&gt; Z
   | S nminusone -&gt; S S S (multbythree nminusone)
in fun collatz : nat -&gt; nat =
  \ n : nat -&gt;
    ifz (isone n) of
      Z -&gt; (
        ifz (iseven n) of
          Z -&gt; collatz (S (multbythree n))
        | S p -&gt; (collatz (divbytwo n))
      )
    | S p -&gt; (S Z)
in (collatz (S S Z))</code></pre>
<p>And here’s how to run the code:</p>
<pre><code>git clone somewhere
install sml
$ sml
- CM.make &quot;path/to/pcf.cm&quot;;
- runFile &quot;path/to/collatz.pcf&quot;;</code></pre>
<p>And here’s a discussion in plain terms about what all the pieces and parts of this means:</p>
<h2 id="natural-numbers">natural numbers</h2>
<p><code>Z</code> is the natural number 0. <code>S Z</code> is 1 (the succesor of one). <code>S S Z</code> is 2, and so on.</p>
<h2 id="functions">functions</h2>
<p>In pcf, functions are expressions just like numbers are. pcf supports anonymous functions and named, recursive functions.</p>
<p>Here are some example anonymous functions.</p>
<pre><code>\ x : nat -&gt; x
\ x : nat -&gt; (\ y : nat -&gt; y)</code></pre>
<p>Functions are applied to their arguments by juxtaposition.</p>
<pre><code>((\ x : nat -&gt; x) Z)</code></pre>
<p>Here’s a divide-by-two function:</p>
<pre><code>fun divbytwo : nat -&gt; nat =
  \ n : nat -&gt;
    ifz n of
      Z -&gt; Z
    | S p -&gt; ifz p of Z -&gt; Z | S p&#39; -&gt; (S (divbytwo p&#39;))
in divbytwo (S S S S Z)</code></pre>
<p>If the number is zero, we’re done. Otherwise, it has some predecessor number <code>p</code>. If <code>p</code> is zero, then return zero (taking the floor). Otherwise, recurse on the predecessor of the predecessor <code>n-2</code> and add one to whatever that gave us.</p>
<p>Under the hood, recursive functions are implemented as a fixed point expression that substitutes itself in for itself. It’s like a recursive function, but it doesn’t have to be a function, it can be any expression. Here’s an amusing way to loop forever:</p>
<pre><code>fix loop : nat in loop</code></pre>
<h2 id="variables">variables</h2>
<pre><code>let x : nat = Z in x</code></pre>
<p>binds the name <code>x</code> in the expression following the <code>in</code> keyword.</p>
<h2 id="parametric-polymorphism">parametric polymorphism</h2>
<p>Parametric polymorphism lets us reuse code you wrote for many different types, with the guarantee that the code will behave the same for all types.</p>
<pre><code>poly t -&gt; \ x : t -&gt; x</code></pre>
<p>is the polymorphic identity function. Feed it a type to get the identity function on that type. e.g.</p>
<pre><code>(poly t -&gt; \ x : t -&gt; x) nat</code></pre>
<p>evaluates to the identity function on natural numbers.</p>
<h2 id="thanks">thanks</h2>
<p>I’ve mostly been working out of Bob Harper’s “Practical Foundations for Programming Languages,” though Pierce’s “Types and Programming Languages” has been a useful source of examples and exposition as well. I am also grateful to Rob Simmons and every other contributor to the SML starter code for CMU’s Fall 2016 compilers course.</p>
<p>pcf was originally introduced by Gordon Plotkin and stands for “programming language for computable functions.”</p>
<h2 id="ps">ps</h2>
<p>Sorry about the abbreviated git commit history (if you care at all). The “first commit” is really like 100 or so commits spread intermittently across a couple months.</p>
<p>I wrote more code for more features on top of this (existential and recursive types), then wanted to add even more features (ooh mutable data ooh linear types), then got worried about mixing those features together, so I cut this “branch” out as a separate repo both for my own reference as a simpler starting place and also as a way to call something “done.” (for once!)</p>
<p>enjoy!</p>
</body>
</html>

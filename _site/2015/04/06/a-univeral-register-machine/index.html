<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      A Universal Register Machine &middot; dfa.io
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="dfa.io" href="/atom.xml">

  <!-- MathJax -->
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
   <script type="text/x-mathjax-config"> 
     MathJax.Hub.Config({   tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); 
  </script>
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/" title="Home">dfa.io</a>
          <!-- <small><a href="http://evanbergeron.com" title="Site">about</a></small> -->
          | <small><a href="/about" title="Site">about</a></small> |
          <small><a href="/archive" title="Site">archive</a></small>
          <!-- <small>a regular tech blog</small> -->
            <!--  -->
            <!--   &nbsp;&nbsp;&nbsp; -->
            <!--   <small><a href="/archive.html"></a></small> -->
            <!--  -->
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">A Universal Register Machine</h1>
  <time datetime="2015-04-06T00:00:00-05:00" class="page-date">06 Apr 2015</time>
  <p>Register machines are yet another abstract model of computation. They’re actually quite interesting for a number of reasons and oftentimes they prove to be a prettier model than Turing Machines.</p>

<p>So what is a register machine, you ask? A register machine is a finite collection of registers and a control unit. Each register holds a natural number and the control unit executes commands that modify the contents of the registers. We write \(R_i\) for the \(i\)th register. Our instruction set is super simple:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="nf">inc</span> <span class="no">r</span> <span class="no">k</span>
<span class="nf">dec</span> <span class="no">r</span> <span class="no">k</span> <span class="no">l</span>
<span class="nf">halt</span></code></pre></div>

<p>\(\texttt{inc}\) increments register \(r\) and then goes to line \(k\) in the program. \(\texttt{dec}\) checks to see if register \(r\) is zero. If it’s not, \(\texttt{dec}\) decrements the register by 1 and then goes to line \(k\). Otherwise, it doesn’t decrement and instead just moves to line \(l\) in the program. \(\texttt{halt}\) is pretty self-explanatory.</p>

<p>To make things nicer, we’ll often label our registers. (X, Y, and so on).</p>

<p>As a first example, here we define an addition function that takes two registers X and Y and places X + Y in Z.</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># addition: X + Y -&gt; Z</span>
<span class="lineno">2</span> <span class="nf">dec</span> <span class="no">X</span> <span class="mi">3</span> <span class="mi">4</span> <span class="c"># while X != 0: X--, Z++</span>
<span class="lineno">3</span> <span class="nf">inc</span> <span class="no">Z</span> <span class="mi">2</span>
<span class="lineno">4</span> <span class="nf">dec</span> <span class="no">Y</span> <span class="mi">5</span> <span class="mi">6</span> <span class="c"># while Y != 0: Y--, Z++</span>
<span class="lineno">5</span> <span class="nf">inc</span> <span class="no">Z</span> <span class="mi">4</span>
<span class="lineno">6</span> <span class="nf">halt</span></code></pre></div>

<p>Similarly, we could define a multiplication algorithm as follows:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># multiplication: X * Y -&gt; Z</span>
<span class="lineno">2</span> <span class="nf">dec</span> <span class="no">X</span> <span class="mi">3</span> <span class="mi">8</span>
<span class="lineno">3</span> <span class="nf">dec</span> <span class="no">Y</span> <span class="mi">4</span> <span class="mi">6</span>
<span class="lineno">4</span> <span class="nf">inc</span> <span class="no">U</span> <span class="mi">5</span>
<span class="lineno">5</span> <span class="nf">inc</span> <span class="no">Z</span> <span class="mi">3</span>
<span class="lineno">6</span> <span class="nf">dec</span> <span class="no">U</span> <span class="mi">7</span> <span class="mi">2</span>
<span class="lineno">7</span> <span class="nf">inc</span> <span class="no">Y</span> <span class="mi">6</span>
<span class="lineno">8</span> <span class="nf">halt</span></code></pre></div>

<p>If we recall from a couple posts back, we showed that, without loss, a Turing machine can have access to its own source code. There’s a similar trick we can play with register machines, though it’s far less involved. It involves something called <em>Godel numberings</em>. It’s one of the features of register machines I quite like.</p>

<p>In essence, Godel numbering is a hack that turns anything into a number. Then, we can encode a register machine program as a number and feed that as input to another register machine. Self-reference!</p>

<p>We’re going to building a toolbox of functions to help us swap between register machines and numbers. We’ll need a couple of things: a coding function, a length function, and decoding function. The coding function will turn a sequence of numbers into a single number. The length function will give us the length of our sequence number. Our decoding function decodes (or extracts) out elements from our sequence.</p>

<p>Essentially, we’re encoding a list of numbers as a single (quite large) number.</p>

<h3 id="coding-functions">Coding Functions</h3>

<p>We define a class of functions called <em>coding functions</em>. Coding functions turn a sequence of numbers into a single number. More formally, it’s a “polyadic map” of the form</p>

<p>\[f : \mathbb{N}^* \rightarrow \mathbb{N}\]</p>

<p>Polyadic just means that it takes multiple arguments. To build such a function, we first define a pairing function of the form</p>

<p>\[\pi : \mathbb{N}^2 \rightarrow \mathbb{N}\]</p>

<p>There’s a number of different ways we could go about defining such a pairing function. Here’s one idea: take two numbers \(x\) and \(y\). Turn them into unary (that is, two strings of length \(x\) and \(y\), respectively), then concatenate these strings together with some sort of delimiter. For example,</p>

<p>\[\pi(3, 5) = 10000010001_2 = 1041\]</p>

<p>There’s a number of other various ways to go about this, but let’s stick with this as a proof of concept. Then we can define our polyadic coding function as such:</p>

<p>\[ f \text{ (nil)} = 0, f (a_1, \ldots a_n) = f(a_1, f(a_2, \ldots a_n))\]</p>

<p>Where nil is the empty list. If you’re familiar with functional programming, this is essentially just</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">foldl</span> <span class="n">pi</span> <span class="mi">0</span> <span class="p">[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="o">..</span><span class="n">an</span><span class="p">]</span></code></pre></div>

<p>We can define similar length and decoding functions. A length function could perhaps be the binary digit sum of the sequence number (minus 1).</p>

<p>Then, note that we can encode register machine instructions as numbers as well: \(\texttt{halt}\) can be \(0\), \(\texttt{inc r k}\) can be \(f(r, k)\), and \(\texttt{dec r k l}\) can be \(f(r, k, l)\). From here, we can encode entire programs as a sequence of such instructions.</p>

<p>So register machines are numbers. With that in mind, let’s get working on our original task - to define a univeral register machine.</p>

<h3 id="univeral-register-machine">Univeral Register Machine</h3>

<p>A <em>univeral register machine</em> is a register machine that takes another register machine as input and simulates that register machine. This is an important concept. The notion of self-reference has been show to be extraordinarily powerful. It provides a natural definition of recursion, for instance.</p>

<p>To implement such a register machine, we’ll want a couple of macros:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="nf">copy</span> <span class="no">r</span> <span class="no">s</span> <span class="no">k</span>      <span class="c"># Copy r to s, goto k</span>
<span class="nf">zero</span> <span class="no">r</span> <span class="no">k</span> <span class="no">l</span>      <span class="c"># If r is 0, goto k, else goto l</span>
<span class="nf">pop</span> <span class="no">r</span> <span class="no">s</span> <span class="no">k</span>       <span class="c"># s = r[0]; r = r[1:], goto k</span>
<span class="nf">read</span> <span class="no">r</span> <span class="no">t</span> <span class="no">s</span> <span class="no">k</span>    <span class="c"># s = r[t]; goto k, halt if out of bounds</span>
<span class="nf">write</span> <span class="no">r</span> <span class="no">t</span> <span class="no">s</span> <span class="no">k</span>   <span class="c"># r[t] = s; goto k, halt if out of bounds</span></code></pre></div>

<h3 id="some-macros">Some Macros</h3>

<p>What follows are implementations for each of the above macros. Copy is fairly straightforward:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># copy r s k</span>
<span class="lineno">2</span> <span class="nf">dec</span> <span class="no">s</span> <span class="mi">2</span> <span class="mi">3</span> <span class="c"># set s = 0</span>
<span class="lineno">3</span> <span class="nf">dec</span> <span class="no">r</span> <span class="mi">4</span> <span class="mi">6</span> <span class="c"># move r to u and s</span>
<span class="lineno">4</span> <span class="nf">inc</span> <span class="no">u</span> <span class="mi">5</span>
<span class="lineno">5</span> <span class="nf">inc</span> <span class="no">s</span> <span class="mi">3</span>
<span class="lineno">6</span> <span class="nf">dec</span> <span class="no">u</span> <span class="mi">7</span> <span class="mi">9</span> <span class="c"># move u back to r</span>
<span class="lineno">7</span> <span class="nf">inc</span> <span class="no">s</span> <span class="mi">6</span>
<span class="lineno">8</span> <span class="nf">dec</span> <span class="no">u</span> <span class="mi">8</span> <span class="no">k</span></code></pre></div>

<p>The zero macro is straightforward as well:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># zero r k l</span>
<span class="lineno">2</span> <span class="nf">dec</span> <span class="no">r</span> <span class="mi">3</span> <span class="no">k</span>
<span class="lineno">3</span> <span class="nf">inc</span> <span class="no">r</span> <span class="no">l</span></code></pre></div>

<p>For pop, given our specific encoding, it happens to be useful to define a div macro that has conditional branches, depending on the value of the bit we just removed.</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># div2 r k l</span>
<span class="lineno">2</span> <span class="nf">dec</span> <span class="no">u</span> <span class="mi">2</span> <span class="mi">3</span> <span class="c"># zero-out register u</span>
<span class="lineno">3</span> <span class="nf">dec</span> <span class="no">r</span> <span class="mi">4</span> <span class="mi">5</span> <span class="c"># u = r; r = 0</span>
<span class="lineno">4</span> <span class="nf">inc</span> <span class="no">u</span> <span class="mi">3</span>
<span class="lineno">5</span> <span class="nf">dec</span> <span class="no">u</span> <span class="mi">6</span> <span class="no">k</span> <span class="c"># if u is zero, r was even</span>
<span class="lineno">6</span> <span class="nf">dec</span> <span class="no">u</span> <span class="mi">7</span> <span class="no">l</span> <span class="c"># if u is zero, r was odd</span>
<span class="lineno">7</span> <span class="nf">inc</span> <span class="no">r</span> <span class="mi">5</span></code></pre></div>

<p>This is a bit more subtle. We first zero out some dummy register u, and then move r’s contents into u. Then, we decrement u twice and increment r once. If, in the first dec instruction, we find that we’ve hit zero, then u was originally even, as an even number of dec instructions preceded it. Similarly, if we hit zero before the second dec instruction, there was an odd number of decrements prior to us, so r must have been odd.</p>

<p>With this macro, pop becomes fairly straightforward:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># pop r s k</span>
<span class="lineno">2</span> <span class="nf">div2</span> <span class="no">r</span> <span class="mi">3</span> <span class="p">-</span> <span class="c"># get rid of leading 1</span>
<span class="lineno">3</span> <span class="nf">div2</span> <span class="no">r</span> <span class="mi">4</span> <span class="mi">5</span> <span class="c"># eat up all zeroes, add to s</span>
<span class="lineno">4</span> <span class="nf">inc</span> <span class="no">s</span> <span class="mi">3</span>
<span class="lineno">5</span> <span class="nf">add</span> <span class="no">r</span> <span class="no">r</span> <span class="mi">6</span>  <span class="c"># We also ate the next 1, so fix that</span>
<span class="lineno">6</span> <span class="nf">dec</span> <span class="no">u</span> <span class="mi">6</span> <span class="mi">7</span>
<span class="lineno">7</span> <span class="nf">inc</span> <span class="no">u</span> <span class="mi">8</span>
<span class="lineno">8</span> <span class="nf">add</span> <span class="no">r</span> <span class="no">u</span> <span class="no">k</span></code></pre></div>

<p>Where \(\texttt{add}\) is some destructive add macro. Note that there is no third argument to the first \(\texttt{div2}\) instruction, as our precondition is that r holds a valid sequence number, whose least significant bit is guaranteed to be 1. So we leave this behavior undefined.</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># read r t s k</span>
<span class="lineno">2</span> <span class="nf">copy</span> <span class="no">r</span> <span class="no">u</span> <span class="mi">2</span>   <span class="c"># u = r (non-destructive copy)</span>
<span class="lineno">3</span> <span class="nf">dec</span> <span class="no">t</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="lineno">4</span> <span class="nf">pop</span> <span class="no">u</span> <span class="no">s</span> <span class="mi">3</span>
<span class="lineno">5</span> <span class="nf">pop</span> <span class="no">u</span> <span class="no">s</span> <span class="no">k</span></code></pre></div>

<p>To define write, we’ll want a push macro:</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno">1</span> <span class="c"># push r s k - push s onto r, goto k</span>
<span class="lineno">2</span> <span class="nf">dec</span> <span class="no">s</span> <span class="mi">3</span> <span class="mi">4</span> <span class="c"># push all the zeros onto r</span>
<span class="lineno">3</span> <span class="nf">add</span> <span class="no">r</span> <span class="no">r</span> <span class="mi">2</span>
<span class="lineno">4</span> <span class="nf">dec</span> <span class="no">u</span> <span class="mi">4</span> <span class="mi">5</span> <span class="c"># push the one onto r</span>
<span class="lineno">5</span> <span class="nf">inc</span> <span class="no">u</span> <span class="mi">6</span>
<span class="lineno">6</span> <span class="nf">add</span> <span class="no">u</span> <span class="no">r</span> <span class="no">k</span></code></pre></div>

<p>With this in hand, we can implement write as if r was a stack: popping off t elements, pushing them onto another stack, push our new value onto r, throwing away the top value from our helper stack, and then replacing the values.</p>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno"> 1</span> <span class="c"># write r t s k # r[t] = s; goto k, halt if out of bounds</span>
<span class="lineno"> 2</span> <span class="nf">dec</span>  <span class="no">u</span> <span class="mi">2</span> <span class="mi">3</span>      <span class="c"># initialize - u is our dummy int</span>
<span class="lineno"> 3</span> <span class="nf">dec</span>  <span class="no">v</span> <span class="mi">3</span> <span class="mi">4</span>      <span class="c"># v is our dummy stack</span>
<span class="lineno"> 4</span> <span class="nf">copy</span> <span class="no">t</span> <span class="no">t</span><span class="err">&#39;</span> <span class="mi">5</span>
<span class="lineno"> 5</span> <span class="nf">dec</span>  <span class="no">t</span><span class="err">&#39;</span> <span class="mi">6</span> <span class="mi">9</span>     <span class="c"># while t &gt; 0</span>
<span class="lineno"> 6</span> <span class="nf">pop</span>  <span class="no">r</span> <span class="no">u</span> <span class="mi">7</span>      <span class="c"># pop from r onto u</span>
<span class="lineno"> 7</span> <span class="nf">push</span> <span class="no">v</span> <span class="no">u</span> <span class="mi">8</span>
<span class="lineno"> 8</span> <span class="nf">dec</span>  <span class="no">u</span> <span class="mi">8</span> <span class="mi">5</span>      <span class="c"># clean up u, go again</span>
<span class="lineno"> 9</span> <span class="nf">pop</span>  <span class="no">r</span> <span class="no">u</span> <span class="mi">10</span>     <span class="c"># once more, when t == 0</span>
<span class="lineno">10</span> <span class="nf">push</span> <span class="no">v</span> <span class="no">u</span> <span class="mi">11</span>
<span class="lineno">11</span> <span class="nf">dec</span>  <span class="no">u</span> <span class="mi">11</span> <span class="mi">12</span>
<span class="lineno">12</span> <span class="nf">push</span> <span class="no">r</span> <span class="no">s</span> <span class="mi">14</span>     <span class="c"># push s onto r</span>
<span class="lineno">13</span> <span class="nf">pop</span>  <span class="no">v</span> <span class="no">u</span> <span class="mi">14</span>     <span class="c"># throw away top value on v</span>
<span class="lineno">14</span> <span class="nf">dec</span>  <span class="no">u</span> <span class="mi">14</span> <span class="mi">15</span>    <span class="c"># (this is what we&#39;re overwriting)</span>
<span class="lineno">15</span> <span class="nf">dec</span>  <span class="no">t</span> <span class="mi">16</span> <span class="no">k</span>     <span class="c"># while t != 0:</span>
<span class="lineno">16</span> <span class="nf">pop</span>  <span class="no">v</span> <span class="no">u</span> <span class="mi">17</span>     <span class="c"># pop from v, push onto u</span>
<span class="lineno">17</span> <span class="nf">push</span> <span class="no">r</span> <span class="no">u</span> <span class="mi">18</span>
<span class="lineno">18</span> <span class="nf">dec</span>  <span class="no">u</span> <span class="mi">18</span> <span class="mi">15</span></code></pre></div>

<h3 id="a-urmp">A URMP</h3>

<p>With these macros in hand, we can write the man himself: a universal register machine program! Here are the registers we use for our program:</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">p</span> <span class="o">-</span> <span class="n">our</span> <span class="n">simulated</span> <span class="n">program</span>
<span class="n">c</span> <span class="o">-</span> <span class="n">the</span> <span class="n">code</span> <span class="n">number</span> <span class="n">of</span> <span class="n">P</span>
<span class="n">x</span> <span class="o">-</span> <span class="n">input</span> <span class="n">to</span> <span class="n">P</span>
<span class="n">r</span> <span class="o">-</span> <span class="n">simulates</span> <span class="n">registers</span> <span class="n">of</span> <span class="n">P</span>
<span class="n">i</span> <span class="o">-</span> <span class="n">instructions</span> <span class="n">of</span> <span class="n">P</span>
<span class="n">p</span> <span class="o">-</span> <span class="n">program</span> <span class="n">counter</span></code></pre></div>

<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span class="lineno"> 1</span> <span class="nf">copy</span>  <span class="no">c</span> <span class="no">r</span> <span class="mi">2</span>
<span class="lineno"> 2</span> <span class="nf">write</span> <span class="no">r</span> <span class="no">p</span> <span class="no">x</span> <span class="mi">3</span>
<span class="lineno"> 3</span> <span class="nf">read</span>  <span class="no">c</span> <span class="no">p</span> <span class="no">i</span> <span class="mi">4</span>
<span class="lineno"> 4</span> <span class="nf">pop</span>   <span class="no">i</span> <span class="no">r</span> <span class="mi">5</span>
<span class="lineno"> 5</span> <span class="nf">zero</span>  <span class="no">i</span> <span class="mi">14</span> <span class="mi">6</span>
<span class="lineno"> 6</span> <span class="nf">pop</span>   <span class="no">i</span> <span class="no">p</span> <span class="mi">7</span>
<span class="lineno"> 7</span> <span class="nf">read</span>  <span class="no">r</span> <span class="no">r</span> <span class="no">x</span> <span class="mi">8</span>
<span class="lineno"> 8</span> <span class="nf">zero</span>  <span class="no">i</span> <span class="mi">9</span> <span class="mi">10</span>
<span class="lineno"> 9</span> <span class="nf">inc</span>   <span class="no">x</span> <span class="mi">13</span>
<span class="lineno">10</span> <span class="nf">zero</span>  <span class="no">x</span> <span class="mi">11</span> <span class="mi">12</span>
<span class="lineno">11</span> <span class="nf">pop</span>   <span class="no">i</span> <span class="no">p</span> <span class="mi">3</span>
<span class="lineno">12</span> <span class="nf">dec</span>   <span class="no">x</span> <span class="mi">13</span> <span class="mi">13</span>
<span class="lineno">13</span> <span class="nf">write</span> <span class="no">r</span> <span class="no">r</span> <span class="no">x</span> <span class="mi">3</span>
<span class="lineno">14</span> <span class="nf">halt</span></code></pre></div>


</article>

<aside class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="//2015/04/07/Phone-A-Friend-and-SUPERHALTS/">
            Phone-a-Friend and SUPERHALTS
            <small><time datetime="2015-04-07T00:00:00-05:00">07 Apr 2015</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="//2015/03/25/randomized-quicksort/">
            Randomized Quicksort
            <small><time datetime="2015-03-25T00:00:00-05:00">25 Mar 2015</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="//2015/03/13/a-turing-machine-quine/">
            A Turing Machine Quine
            <small><time datetime="2015-03-13T00:00:00-05:00">13 Mar 2015</time></small>
          </a>
        </h3>
      </li>
    
  </ul>
</aside>

      </main>

      <footer class="footer">
        <small>
          &copy; <time datetime="2015-04-07T02:14:52-05:00">2015</time>. All rights reserved.
        </small>
      </footer>
    </div>

  </body>
</html>

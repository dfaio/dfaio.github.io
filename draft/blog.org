* Basically a compiler-writing diary entry - July 23, 217
I rewrote the whole back half of the compiler this weekend.

** Code 

Just before the weekend started, I finished simply typed closure
conversion (though it's still buggy; type-theory explanation why
later).

It felt pretty satisfying to determinedly work on the code for many
hours, though. There were definitely a couple multiple-hour-long
stretches where I just forced myself to write the easy parts of the
code. Funny how the hard code still doesn't quite work.

** Typechecking intermediate representations
   
Typechecking ILClos actually saved me a nasty bug today. I'm not sure
I'm totally sold on whether type-directed translations are quite worth
the type-related overhead, but this sways me a bit. It's also pretty
nice having that extra assertion in the middle of the pipeline. The
LLVM style guidelines recommend asserting often; this seems like an
instance of that to me. It feels similar to unit-testing your
code. It's like automatically calling unit tests during integration
tests.

** Getting rid of symbol tables
This is a tip from GHC, though I owe it to [TODO this blog post]. The
term 'symbol table' refers to (basically) a hash table mapping
identifiers (type names, variables, etc.) to
good-old-fashioned-metadata-stuff.

I made variables track their own type information.

** Each closure is two structs and a function pointer.
Closures are structs. The struct has a env pointer and a code
pointer. The env and code pointers can be constructed at closure
creation time; we have all the relevant values in scope. 

A closure may be applied to an enviornment, but not called. This value
could be returned. Consider

  \ x: nat. \ y: nat. Succ (x) 
            |-- is a value --|
	    
Then at closure call time, we've passed the (either heap allocated or
passed-by-value) struct around. Call closure->func(closure->env,
arg) in invoke the closure.

*** Some of my incorrect approaches

I was running into a chicken and egg problem because I was conflating
the enviornment struct with the overall closure struct. I had
something to the effect of

  // WRONG - typedefs are not recursive!
  typedef struct Closure {
    int env_variable_1;
    int env_variable_1;
          ...
    int env_variable_n;
    int (*code)(Clos, int);
  } Clos;

  
*** A correct approach

  typedef struct ClosureEnv {
    int env_variable_1;
    int env_variable_1;
          ...
    int env_variable_n;
  } Clos;
  
  // Function pointer typedef
  typedef int (*ClosureCodeType)(ClosureEnv, int);
  
  typedef struct Closure {
    ClosureEnv env;
    ClosureCodeType code;
  } Closure;

Closure creation time constructs the ClosureEnv struct and pairs it
with the function pointer. It's this separation of enviornment and
closure argument that's critical.

Closure call time simply calls clos->code(clos->env, arg).

*** An optimization?
I think this works. I flip-flop'd on it while writing this, twice.

  // WRONG - does not separate pairing with enviornment 
  // and actual application.
  typedef struct Closure {
    int env_variable_1;
    int env_variable_1;
          ...
    int env_variable_n;
    int (*code)(int, .. int, int);
  } Clos;
  
Closure creation time simply assigns into each field. Closure call
time becomes

  clos->code(clos->env_variable_1, ..., clos->env_variable_n, arg) 
  
TODO - is this any better? Might spare us pointer dereferences in
clos->code, by eating them once up front. But what if they're never
used? Ah, but we know all of them are used, since we only close over
the necassary variables. So it really depends on how many times the
values are referenced. I think it's likely that the register
allocation in any mature C compiler will make the difference
marginal. Unless we use the value a lot...?

*** Comments 

I actually used writing this post as method to think aloud about the
problem.

The way I think about closures during closure conversion and during
codegen is pretty different; I wonder if that's a design flaw in my
code, or if this is really just some two-stage nature of closure
conversion as a compiler pass.

** Still need to use existential types in simply-typed closure conversion.
   
Simply-typed closure conversion still needs to switch to existential
types for representing closures, though; I'm currently doing a naive
pair-and-projection representation. I'm just not sure how to feed the
'pack' and 'unpack' expressions down into C...

I actually didn't realize this until writing the post; nice.

*** Mini explanation why this is an issue.
(I basically owe this explanation to the 'Typed Closure Conversion'
paper, but I'm writing it up here for (mostly my benefit but also)
your benefit.

Wasn't that parenthetical so hard to read? Too much cleverness for
good writing. I'm leaving it in, though.

Friendly reminder: closures are (usually) functions that reference (by
value) variables defined in external (lexical) scopes.

I'm trying to turn them into structs and function pointers in C. The
struct holds the values of those externally-defined variables. 

** Code design question
One general functional-code-style design question: I never know when
to go with vectors or nested-linked-list style AST representations.

I'm two blog posts in and I still don't have a working compiler :P

*** Rust format
It's nice to something just say 'fuck it' with formatting source code,
but it makes it harder to read later. It'd be nice if there was
block-style indentation for enum variants. If I was really picky, I
could look into adding this to rustfmt, I suppose...? How do I open
source.

*** Rust references are hard to use.
I'd like to all identifiers made by the compiler be allocated only
once, being passed by reference through the whole compiler (starting
from the parser - eat the memory for the file and all the identifiers,
plus a bunch of pointers). Currently I'm reallocating every time,
because passing rust 'String''s around is way easier than passing
'%str.' Isn't that dumb? I'd like to fix that.

But I still don't understand lifetimes well enough to do this. I
understand the idea in abstract, but writing reference-y code that
actually compilers is tough. I'd either need to see examples or write
tiny tree-traversal programs to actually do this.

It's tough to find advice on these sorts of problems, also. There's
not many resources for Rust beyond the basics (nothing on the order of
'Effective C++,' which is basically what I'm looking for in Rust).

*** Using Rust to write this is 'walking the talk'
At the very least, it's using code written by others in the compiler
community. Sometimes I think it'd be fun to write the compiler in one
of those small-but-ambitious languages implemented in C/C++.

If I'm making another useless programming language (wih maybe some
cool hip features later, depending on my long-term motivation), it
makes sense to use one such 

This post was inspired by Rui Ueyama's post about writing 8cc. 

** Ergonomics
My fingers actually hurt typing this; I wrote more than 600 lines of
code. Even with trying to be smart with vim editing patterns, my
fingers still feel sore. I should set up a Space-Leader based 'cargo
run' command.

It might be smart for me to invest in some ergonomic keyboard, but I
worry about being able to use laptops happily, and I really enjoy
biking to places to code.
